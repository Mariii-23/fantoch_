use crate::id::ProcessId;
use std::collections::{HashMap, HashSet};
use std::mem;

type Ballot = u64;

/// Implementation of Flexible single-decree Paxos in which:
/// - phase-1 waits for n - f promises
/// - phase-2 waits for f + 1 accepts
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum SynodMessage<V> {
    // messages to acceptor
    MPrepare(Ballot),
    MAccept(Ballot, V),
    // messages to proposer
    MPromise(Ballot, Accepted<V>),
    MAccepted(Ballot),
    // message to be handled by user of this module
    MChosen(V),
}

#[derive(Clone)]
pub struct Synod<V> {
    // paxos agents
    proposer: Proposer<V>,
    acceptor: Acceptor<V>,
}

#[allow(dead_code)]
impl<V> Synod<V>
where
    V: Default + Clone,
{
    /// Creates a new Synod instance.
    /// After executing phase-1, if the proposer sees that no proposal has been accepted before, it
    /// resorts to the proposal generator to compute a new consensus proposal given all values
    /// reported by the phase-1 quorum. We know that none of the values reported were accepted
    /// because they're tagged with ballot 0.
    pub fn new(
        process_id: ProcessId,
        n: usize,
        f: usize,
        proposal_gen: fn(HashMap<ProcessId, V>) -> V,
    ) -> Self {
        Self {
            proposer: Proposer::new(process_id, n, f, proposal_gen),
            acceptor: Acceptor::new(),
        }
    }

    /// Set the consensus value if no value has been accepted yet (i.e. ballot is still 0). If the
    /// value was successfully changed, `true` is returned and `false` otherwise.
    #[must_use]
    pub fn maybe_set_value<F>(&mut self, value_gen: F) -> bool
    where
        F: FnOnce() -> V,
    {
        self.acceptor.maybe_set_value(value_gen)
    }

    /// Returns the current consensus value (not necessarily accepted).
    pub fn value(&self) -> &V {
        self.acceptor.value()
    }

    /// Creates a new prepare message with a ballot onwed by this process. This ballot is greater
    /// than any ballot seen the by local acceptor agent.
    /// Feeding the proposer with the highest ballot seen by the acceptor increases the likelyhood
    /// of having this new prepare accepted. And since the created Prepare will be delivered
    /// imediately at the local acceptor, this ensures that the ballots created are unique.
    ///
    /// TODO how do we ensure that the prepare is delivered immediately?
    pub fn new_prepare(&mut self) -> SynodMessage<V> {
        self.proposer.new_prepare(&self.acceptor)
    }

    /// Handles `SynodMessage`s generated by this `Synod` module by forwarding them to the proper
    /// Paxos agent (i.e. either the proposer or the acceptor). All messages should be handled
    /// here with the exeception of the `SynodMessage::MChosen` that should be handled outside.
    pub fn handle(&mut self, from: ProcessId, msg: SynodMessage<V>) -> Option<SynodMessage<V>> {
        match msg {
            // handle messages to acceptor
            SynodMessage::MPrepare(b) => self.acceptor.handle_prepare(b),
            SynodMessage::MAccept(b, value) => self.acceptor.handle_accept(b, value),
            // handle messages to proposer
            SynodMessage::MPromise(b, previous) => self.proposer.handle_promise(from, b, previous),
            SynodMessage::MAccepted(b) => self.proposer.handle_accepted(from, b),
            SynodMessage::MChosen(_) => panic!(
                "MChosen messages are supposed to be handled outside of this Synod abstraction"
            ),
        }
    }
}

type Promises<V> = HashMap<ProcessId, Accepted<V>>;
type Accepts = HashSet<ProcessId>;
type Proposal<V> = Option<V>;

#[derive(Clone)]
struct Proposer<V> {
    // process identifier
    process_id: ProcessId,
    // number of processes
    n: usize,
    // maximum number of allowed failures
    f: usize,
    // ballot used in prepare
    ballot: Ballot,
    // proposal generator that will be used once enough promises have been collected
    proposal_gen: fn(HashMap<ProcessId, V>) -> V,
    // what follows is paper-slip state:
    // - promises: mapping from phase-1 quorum processes to the values in their promises
    // - accepts: set of processes that have accepted a proposal
    // - proposal: proposal generated by the proposal generator
    promises: Promises<V>,
    accepts: Accepts,
    proposal: Proposal<V>,
}

impl<V> Proposer<V>
where
    V: Clone + Default,
{
    /// Creates a new proposer.
    fn new(
        process_id: ProcessId,
        n: usize,
        f: usize,
        proposal_gen: fn(HashMap<ProcessId, V>) -> V,
    ) -> Self {
        Self {
            process_id,
            n,
            f,
            ballot: 0,
            proposal_gen,
            promises: HashMap::new(),
            accepts: HashSet::new(),
            proposal: None,
        }
    }

    /// Generates a new prepare. See top-level docs (in `Synod`) for more info.
    fn new_prepare(&mut self, acceptor: &Acceptor<V>) -> SynodMessage<V> {
        // the acceptor's ballot should be at least as high as the proposer's ballot (if this is not
        // the case, it's because prepare messages are not delivered locally immediately)
        assert!(acceptor.ballot() >= self.ballot);

        // generate the next ballot
        self.next_ballot(acceptor.ballot());

        // the new ballot should be higher than the acceptor's ballot
        assert!(acceptor.ballot() < self.ballot);

        // reset paper-slip state
        self.reset_state();

        // create prepare message
        let prepare = SynodMessage::MPrepare(self.ballot);
        prepare
    }

    /// Changes the ballot to a ballot owned by this proposer. This new ballot is higher than the
    /// ballot the acceptor is currently in, which should increase the likelyhood of this ballot
    /// being accepted by other acceptors.
    fn next_ballot(&mut self, acceptor_current_ballot: Ballot) {
        // get number of processes
        let n = self.n as u64;
        // compute "round" of current ballot
        let round = acceptor_current_ballot / n;
        // compute the next "round"
        let next_round = round + 1;
        // compute ballot owned by this process in the next round
        self.ballot = self.process_id + n * next_round;
    }

    /// Resets the local (paper-slip) state (promises received, accepts received, and proposal
    /// sent), returning the previous value of promises and proposal.
    fn reset_state(&mut self) -> (Promises<V>, Proposal<V>) {
        // reset promises
        let mut promises = HashMap::new();
        mem::swap(&mut promises, &mut self.promises);

        // reset accepts
        self.accepts = HashSet::new();

        // reset proposal
        let mut proposal = None;
        mem::swap(&mut proposal, &mut self.proposal);

        // return previous promises and proposal
        (promises, proposal)
    }

    fn handle_promise(
        &mut self,
        from: ProcessId,
        b: Ballot,
        accepted: Accepted<V>,
    ) -> Option<SynodMessage<V>> {
        // check if it's a promise about the current ballot (so that we only process promises about
        // the current ballot)
        if self.ballot == b {
            // if yes, update set of promises
            self.promises.insert(from, accepted);

            // check if we have enough (i.e. n - f) promises
            if self.promises.len() == self.n - self.f {
                // if we do, check if any value has been accepted before:
                // - if yes, select the value accepted at the highest ballot
                // - if not, generate proposal using the generator

                // reset state and get promises
                let (mut promises, _) = self.reset_state();

                // compute the proposal accepted at the highest ballot
                let (highest_ballot, from) = promises
                    .iter()
                    // get highest proposal
                    .max_by_key(|(_process, (ballot, _value))| ballot)
                    // extract ballot and process
                    .map(|(process, (ballot, _))| (*ballot, *process))
                    .expect("there should n - f promises, and thus, there's a highest value");

                // compute our proposal depending on whether there was a previously accepted
                // proposal
                let proposal = if highest_ballot == 0 {
                    // if the highest ballot is 0, use the proposal generator to generate
                    // anything we want
                    // TODO do we need to collect here? also, maybe we could simply upstream the
                    // ballots, even though they're all 0
                    let values = promises
                        .into_iter()
                        .map(|(process, (_ballot, value))| (process, value))
                        .collect();
                    (self.proposal_gen)(values)
                } else {
                    // otherwise, we must propose the value accepted at the highest ballot
                    // TODO this scheme of removing the value from `promises` prevents cloning
                    // the value when we only have a reference to it; is there a better way?
                    promises.remove(&from).map(|(_ballot, value)| value).expect(
                        "a promise from this process must exists as it was the highest promise",
                    )
                };

                // save the proposal
                self.proposal = Some(proposal.clone());

                // create accept message
                let accept = SynodMessage::MAccept(b, proposal);
                return Some(accept);
            }
        }
        None
    }

    fn handle_accepted(&mut self, from: ProcessId, b: Ballot) -> Option<SynodMessage<V>> {
        // check if it's an accept about the current ballot (so that we only process accepts about
        // the current ballot)
        if self.ballot == b {
            // if yes, update set of accepts
            self.accepts.insert(from);

            // check if we have enough (i.e. f + 1) accepts
            if self.accepts.len() == self.f + 1 {
                // if we do, our proposal can be chosen

                // reset state and get proposal
                let (_, proposal) = self.reset_state();

                // extract proposal
                let proposal =
                    proposal.expect("there should have been proposal before a value can be chosen");

                // create chosen message
                let chosen = SynodMessage::MChosen(proposal);
                return Some(chosen);
            }
        }
        None
    }
}

// The first component is the ballot in which the value (the second component) was accepted.
// If the ballot is 0, the value has not been accepted yet.
type Accepted<Value> = (Ballot, Value);

#[derive(Clone)]
struct Acceptor<Value> {
    ballot: Ballot,
    accepted: Accepted<Value>,
}

impl<V> Acceptor<V>
where
    V: Default + Clone,
{
    fn new() -> Self {
        Self {
            ballot: 0,
            accepted: (0, V::default()),
        }
    }

    // Set the consensus value if no value has been accepted yet.
    fn maybe_set_value<F>(&mut self, value_gen: F) -> bool
    where
        F: FnOnce() -> V,
    {
        if self.ballot == 0 {
            self.accepted = (0, value_gen());
            true
        } else {
            false
        }
    }

    // Retrieves consensus value (not necessarily accepted).
    fn value(&self) -> &V {
        let (_, v) = &self.accepted;
        v
    }

    // Returns the ballot that the acceptor is currently in.
    fn ballot(&self) -> Ballot {
        self.ballot
    }

    // The reply to this prepare request contains:
    // - a promise to never accept a proposal numbered less than `b`
    // - the proposal accepted with the highest number less than `b`, if any
    fn handle_prepare(&mut self, b: Ballot) -> Option<SynodMessage<V>> {
        // since we need to promise that we won't accept any proposal numbered less then `b`,
        // there's no point in letting such proposal be prepared, and so, we ignore such prepares
        if b > self.ballot {
            // update current ballot
            self.ballot = b;
            // create promise message
            let promise = SynodMessage::MPromise(b, self.accepted.clone());
            Some(promise)
        } else {
            None
        }
    }

    fn handle_accept(&mut self, b: Ballot, value: V) -> Option<SynodMessage<V>> {
        if b >= self.ballot {
            // update current ballot
            self.ballot = b;
            // update the accepted value
            self.accepted = (b, value);
            // create accepted message
            let accepted = SynodMessage::MAccepted(b);
            Some(accepted)
        } else {
            None
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // generate proposals by summing of the values reported by phase-1 quorum processes
    fn proposal_gen(values: HashMap<ProcessId, u64>) -> u64 {
        values.into_iter().map(|(_, v)| v).sum()
    }

    #[test]
    fn synod_flow() {
        // n and f
        let n = 5;
        let f = 1;

        // create all synods
        let mut synod_1 = Synod::new(1, n, f, proposal_gen);
        let mut synod_2 = Synod::new(2, n, f, proposal_gen);
        let mut synod_3 = Synod::new(3, n, f, proposal_gen);
        let mut synod_4 = Synod::new(4, n, f, proposal_gen);
        let mut synod_5 = Synod::new(5, n, f, proposal_gen);

        // check it's possible to set values (as ballots are still 0), and check value
        assert!(synod_1.maybe_set_value(|| 10));
        assert_eq!(synod_1.value(), &10);
        assert!(synod_2.maybe_set_value(|| 20));
        assert_eq!(synod_2.value(), &20);
        assert!(synod_3.maybe_set_value(|| 30));
        assert_eq!(synod_3.value(), &30);
        assert!(synod_4.maybe_set_value(|| 40));
        assert_eq!(synod_4.value(), &40);
        assert!(synod_5.maybe_set_value(|| 50));
        assert_eq!(synod_5.value(), &50);

        // again
        assert!(synod_1.maybe_set_value(|| 20));
        assert_eq!(synod_1.value(), &20);

        // synod 1: generate prepare
        let prepare = synod_1.new_prepare();

        // it's still possible to set the value as the prepare has not been handled
        assert!(synod_1.maybe_set_value(|| 10));
        assert_eq!(synod_1.value(), &10);

        // handle the prepare at n - f processes, including synod 1
        let promise_1 = synod_1
            .handle(1, prepare.clone())
            .expect("there should a promise from 1");
        let promise_2 = synod_2
            .handle(1, prepare.clone())
            .expect("there should a promise from 2");
        let promise_3 = synod_3
            .handle(1, prepare.clone())
            .expect("there should a promise from 3");
        let promise_4 = synod_4
            .handle(1, prepare.clone())
            .expect("there should a promise from 4");

        // check it's no longer possible to set the value
        assert!(!synod_1.maybe_set_value(|| 20));
        assert_eq!(synod_1.value(), &10);

        // synod 1: handle promises
        let result = synod_1.handle(1, promise_1);
        assert!(result.is_none());
        let result = synod_1.handle(2, promise_2);
        assert!(result.is_none());
        let result = synod_1.handle(3, promise_3);
        assert!(result.is_none());
        // only in the last one there should be an accept message
        let accept = synod_1
            .handle(4, promise_4)
            .expect("there should an accept message");

        // handle the accept at f + 1 processes, including synod 1
        let accepted_1 = synod_1
            .handle(1, accept.clone())
            .expect("there should an accept from 1");
        let accepted_5 = synod_5
            .handle(1, accept.clone())
            .expect("there should an accept from 5");

        // synod 1: handle accepts
        let result = synod_1.handle(1, accepted_1);
        assert!(result.is_none());
        let chosen = synod_1
            .handle(5, accepted_5)
            .expect("there should be a chosen message");

        // check that 100 (the sum of 10 + 20 + 30 + 40, i.e. the ballot-0 values from phase-1
        // processes) was chosen
        assert_eq!(chosen, SynodMessage::MChosen(100));
    }

    #[test]
    fn synod_prepare_with_lower_ballot_fails() {
        // n and f
        let n = 3;
        let f = 1;

        // create all synods
        let mut synod_1 = Synod::new(1, n, f, proposal_gen);
        let mut synod_2 = Synod::new(2, n, f, proposal_gen);
        let mut synod_3 = Synod::new(3, n, f, proposal_gen);

        // synod 1 and 3: generate prepare
        let prepare_a = synod_1.new_prepare();
        let prepare_c = synod_3.new_prepare();

        // handle the prepare_a at synod 1
        synod_1
            .handle(1, prepare_a.clone())
            .expect("there should a promise from 1");

        // handle the prepare_c at synod 3
        synod_3
            .handle(3, prepare_c.clone())
            .expect("there should a promise from 3");

        // handle the prepare_c at synod 2
        synod_2
            .handle(3, prepare_c.clone())
            .expect("there should a promise from 2");

        // handle the prepare_a at synod 2
        let result = synod_2.handle(1, prepare_a.clone());
        // there should be no promise from synod 2
        assert!(result.is_none());
    }

    #[test]
    fn synod_recovery() {
        // n and f
        let n = 3;
        let f = 1;

        // create all synods
        let mut synod_1 = Synod::new(1, n, f, proposal_gen);
        let mut synod_2 = Synod::new(2, n, f, proposal_gen);
        let mut synod_3 = Synod::new(3, n, f, proposal_gen);

        // set values at all synods
        assert!(synod_1.maybe_set_value(|| 10));
        assert_eq!(synod_1.value(), &10);
        assert!(synod_2.maybe_set_value(|| 20));
        assert_eq!(synod_2.value(), &20);
        assert!(synod_3.maybe_set_value(|| 30));
        assert_eq!(synod_3.value(), &30);

        // synod 1: generate prepare
        let prepare = synod_1.new_prepare();

        // handle the prepare at synod 1
        let promise_1 = synod_1
            .handle(1, prepare.clone())
            .expect("there should a promise from 1");

        // handle the prepare at synod 2
        let promise_2 = synod_2
            .handle(1, prepare.clone())
            .expect("there should a promise from 2");

        // synod 1: handle promises
        let result = synod_1.handle(1, promise_1);
        assert!(result.is_none());
        // only in the last one there should be an accept message
        let accept = synod_1
            .handle(2, promise_2)
            .expect("there should an accept message");

        // check the value in the accept
        if let SynodMessage::MAccept(ballot, value) = accept {
            assert_eq!(ballot, 4); // 8 is the ballot from round-1 (n=3 * round=1 + id=1) that belongs to process 1
            assert_eq!(value, 30); // sum of 10 and 20, the values stored by processes 1 and 2
        } else {
            panic!("process 1 should have generated an accept")
        }

        // handle the accept only at synod 1
        synod_1
            .handle(1, accept)
            .expect("there should an accept from 1");

        // at this point, if another process tries to recover, there are two possible situations:
        // - if process 1 is part of that phase-1 quorum, this new process needs to propose the same
        //   value that was proposed by 1 (i.e. 30)
        // - if process 2 is *not* part of that phase-1 quorum, this new process can propose
        //   anything it wants; this value will be 50, i.e. the sum of the values stored by
        //   processes 2 and 3

        // start recovery by synod 2
        let prepare = synod_2.new_prepare();

        // handle prepare at synod 2
        let promise_2 = synod_2
            .handle(2, prepare.clone())
            .expect("there should be a promise from 2");

        // synod 2: handle promise by 2
        let result = synod_2.handle(2, promise_2);
        assert!(result.is_none());

        // check case 1
        case_1(prepare.clone(), synod_1.clone(), synod_2.clone());

        // check case 2
        case_2(prepare.clone(), synod_2.clone(), synod_3.clone());

        // in this case, the second prepare is handled by synod 1
        fn case_1(prepare: SynodMessage<u64>, mut synod_1: Synod<u64>, mut synod_2: Synod<u64>) {
            // handle prepare at synod 1
            let promise_1 = synod_1
                .handle(2, prepare.clone())
                .expect("there should be a promise from 1");

            // synod 2: handle promise from 1
            let accept = synod_2
                .handle(1, promise_1)
                .expect("there should an accept message");

            // check the value in the accept
            if let SynodMessage::MAccept(ballot, value) = accept {
                assert_eq!(ballot, 8); // 8 is the ballot from round-2 (n=3 * round=2 + id=2) that belongs to process 2
                assert_eq!(value, 30); // the value proposed by process 1
            } else {
                panic!("process 2 should have generated an accept")
            }
        }

        // in this case, the second prepare is handled by synod 3
        fn case_2(prepare: SynodMessage<u64>, mut synod_2: Synod<u64>, mut synod_3: Synod<u64>) {
            // handle prepare at synod 3
            let promise_3 = synod_3
                .handle(2, prepare.clone())
                .expect("there should be a promise from 3");

            // synod 2: handle promise from 3
            let accept = synod_2
                .handle(3, promise_3)
                .expect("there should an accept message");

            // check the value in the accept
            if let SynodMessage::MAccept(ballot, value) = accept {
                assert_eq!(ballot, 8); // 8 is the ballot from round-2 (n=3 * round=2 + id=2) that belongs to process 2
                assert_eq!(value, 50); // sum of 20 and 30, the values stored by processes 2 and 3
            } else {
                panic!("process 2 should have generated an accept")
            }
        }
    }
}
