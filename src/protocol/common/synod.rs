use crate::id::ProcessId;
use std::collections::{HashMap, HashSet};
use std::mem;

type Ballot = u64;

/// Implementation of Flexible single-decree Paxos in which:
/// - phase-1 waits for n - f promises
/// - phase-2 waits for f + 1 accepts
pub enum SynodMessage<V> {
    // messages to acceptor
    MPrepare(Ballot),
    MAccept(Ballot, V),
    // messages to proposer
    MPromise(Ballot, Accepted<V>),
    MAccepted(Ballot),
    // message to be handled by user
    MChosen(V),
}

pub struct Synod<V> {
    // paxos agents
    proposer: Proposer<V>,
    acceptor: Acceptor<V>,
}

#[allow(dead_code)]
impl<V> Synod<V>
where
    V: Default + Clone,
{
    /// Creates a new Synod instance.
    /// After executing phase-1, if the proposer sees that no proposal has been accepted before, it
    /// resorts to the proposal generator to compute a new consensus proposal given all values
    /// reported by the phase-1 quorum. We know that none of the values reported were accepted
    /// because they're tagged with ballot 0.
    pub fn new(process_id: ProcessId, n: usize, f: usize, proposal_gen: fn(HashMap<ProcessId, V>) -> V) -> Self
    {
        Self {
            proposer: Proposer::new(process_id, n, f, proposal_gen),
            acceptor: Acceptor::new(),
        }
    }

    /// Set the consensus value if no value has been accepted yet (i.e. ballot is still 0). If the
    /// value was successfully changed, `true` is returned and `false` otherwise.
    #[must_use]
    pub fn maybe_set_value<F>(&mut self, value_gen: F) -> bool
    where
        F: FnOnce() -> V,
    {
        self.acceptor.maybe_set_value(value_gen)
    }

    /// Creates a new prepare message with a ballot onwed by this process. This ballot is greater
    /// than any ballot seen the by local acceptor agent.
    /// Feeding the proposer with the highest ballot seen by the acceptor increases the likelyhood
    /// of having this new prepare accepted. And since the created Prepare will be delivered
    /// imediately at the local acceptor, this ensures that the ballots created are unique.
    ///
    /// TODO how do we ensure that the prepare is delivered immediately?
    pub fn new_prepare(&mut self) -> SynodMessage<V> {
        self.proposer.new_prepare(&self.acceptor)
    }

    /// Handles `SynodMessage`s generated by this `Synod` module by forwarding them to the proper
    /// Paxos agent (i.e. either the proposer or the acceptor). All messages should be handled
    /// here with the exeception of the `SynodMessage::MChosen` that should be handled outside.
    pub fn handle<F>(&mut self, from: ProcessId, msg: SynodMessage<V>) -> Option<SynodMessage<V>> {
        match msg {
            // handle messages to acceptor
            SynodMessage::MPrepare(b) => self.acceptor.handle_prepare(b),
            SynodMessage::MAccept(b, value) => self.acceptor.handle_accept(b, value),
            // handle messages to proposer
            SynodMessage::MPromise(b, previous) => self.proposer.handle_promise(from, b, previous),
            SynodMessage::MAccepted(b) => self.proposer.handle_accepted(from, b),
            SynodMessage::MChosen(_) => panic!(
                "MChosen messages are supposed to be handled outside of this Synod abstraction"
            ),
        }
    }
}

type Promises<V> = HashMap<ProcessId, Accepted<V>>;
type Accepts = HashSet<ProcessId>;

struct Proposer<V> {
    // process identifier
    process_id: ProcessId,
    // number of processes
    n: usize,
    // maximum number of allowed failures
    f: usize,
    // ballot used in prepare
    ballot: Ballot,
    // proposal generator that will be used once enough promises have been collected
    proposal_gen: fn(HashMap<ProcessId, V>) -> V,
    // what follows is paper-slip state:
    // - promises: mapping from phase-1 quorum processes to the values in their promises
    // - accepts: set of processes that have accepted a proposal
    // - proposal: proposal generated by the proposal generator
    promises: Promises<V>,
    accepts: Accepts,
    proposal: Option<V>,
}

impl<V> Proposer<V>
where
    V: Clone + Default,
{
    /// Creates a new proposer.
    fn new(process_id: ProcessId, n: usize, f: usize, proposal_gen: fn(HashMap<ProcessId, V>) -> V) -> Self
    {
        Self {
            process_id,
            n,
            f,
            ballot: 0,
            proposal_gen,
            promises: HashMap::new(),
            accepts: HashSet::new(),
            proposal: None,
        }
    }

    /// Generates a new prepare. See top-level docs (in `Synod`) for more info.
    fn new_prepare(&mut self, acceptor: &Acceptor<V>) -> SynodMessage<V> {
        // the acceptor's ballot should be at least as high as the proposer's ballot (if this is not
        // the case, it's because prepare messages are not delivered locally immediately)
        assert!(acceptor.ballot() >= self.ballot);

        // generate the next ballot
        self.next_ballot(acceptor.ballot());

        // the new balot should be higher than the acceptor's ballot
        assert!(acceptor.ballot() < self.ballot);

        // reset paper-slip state
        self.reset_state();

        // create prepare message
        let prepare = SynodMessage::MPrepare(self.ballot);
        prepare
    }

    /// Changes the ballot to a ballot owned by this proposer. This new ballot is higher than the
    /// ballot the acceptor is currently in, which should increase the likelyhood of this ballot
    /// being accepted by other acceptors.
    fn next_ballot(&mut self, acceptor_current_ballot: Ballot) {
        // get number of processes
        let n = self.n as u64;
        // compute "round" of current ballot
        let round = acceptor_current_ballot / n;
        // compute the next "round"
        let next_round = round + 1;
        // compute ballot owned by this process in the next round
        self.ballot = self.process_id + n * next_round;
    }

    /// Resets the local (paper-slip) state (promises received, accepts received, and proposal),
    /// returning the promises and accepts.
    fn reset_state(&mut self) -> (Promises<V>, Accepts) {
        // reset promises
        let mut promises = HashMap::new();
        mem::swap(&mut promises, &mut self.promises);

        // reset accepts
        let mut accepts = HashSet::new();
        mem::swap(&mut accepts, &mut self.accepts);

        // reset proposal
        self.proposal = None;

        // return previous promises and accepts
        (promises, accepts)
    }

    fn handle_promise(
        &mut self,
        from: ProcessId,
        b: Ballot,
        accepted: Accepted<V>,
    ) -> Option<SynodMessage<V>> {
        // check if it's a promise about the current ballot (so that we only processs promises about
        // the current ballot)
        if self.ballot == b {
            // if yes, update set of promises
            self.promises.insert(from, accepted);

            // check if we have enough (i.e. n - f) promises
            if self.promises.len() == self.n - self.f {
                // if we do, check if any value has been accepted before:
                // - if yes, select the value accepted at the highest ballot
                // - if not, generate proposal using the generator

                // reset state and get promises
                let (promises, _) = self.reset_state();

                // compute the proposal accepted at the highest ballot
                let highest = promises
                    .iter()
                    // get highest proposal
                    .max_by_key(|(_process, (ballot, _value))| ballot)
                    // extract proposal
                    .map(|(_, highest)| highest)
                    .expect("there should n - f promises, and thus, there's a highest value");

                // compute our proposal depending on whether there was a previously accepted
                // proposal
                let proposal = match highest {
                    (0, _) => {
                        // if the highest ballot is 0, use the proposal generator to generate
                        // anything we want
                        // TODO do we need to collect here? also, maybe we could simply upstream the
                        // ballots, even though they're all 0
                        let values = promises
                            .into_iter()
                            .map(|(process, (_ballot, value))| (process, value))
                            .collect();
                        (self.proposal_gen)(values)
                    }
                    (_, value) => {
                        // otherwise, we must propose the value accepted at the highest ballot
                        // TODO can we avoid cloning here?
                        value.clone()
                    }
                };

                // save the proposal
                self.proposal = Some(proposal.clone());

                // create accept message
                let accept = SynodMessage::MAccept(b, proposal);
                return Some(accept);
            }
        }
        None
    }

    fn handle_accepted(&mut self, from: ProcessId, b: Ballot) -> Option<SynodMessage<V>> {
        // check if it's an accept about the current ballot
        if self.ballot == b {
            // if yes, update set of processes that have accepted
            self.accepts.insert(from);
            // generate `MChosen` if we have enough accepts
            if self.accepts.len() == self.f + 1 {
                //
            }
        }
        None
    }
}

// The first component is the ballot in which the value (the second component) was accepted.
// If the ballot is 0, the value has not been accepted yet.
type Accepted<Value> = (Ballot, Value);

struct Acceptor<Value> {
    ballot: Ballot,
    accepted: Accepted<Value>,
}

impl<V> Acceptor<V>
where
    V: Default + Clone,
{
    fn new() -> Self {
        Self {
            ballot: 0,
            accepted: (0, V::default()),
        }
    }

    // Set the consensus value if no value has been accepted yet.
    fn maybe_set_value<F>(&mut self, value_gen: F) -> bool
    where
        F: FnOnce() -> V,
    {
        if self.ballot == 0 {
            self.accepted = (0, value_gen());
            true
        } else {
            false
        }
    }

    // Returns the ballot that the acceptor is currently in.
    fn ballot(&self) -> Ballot {
        self.ballot
    }

    // The reply to this prepare request contains:
    // - a promise to never accept a proposal numbered less than `b`
    // - the proposal accepted with the highest number less than `b`, if any
    fn handle_prepare(&mut self, b: Ballot) -> Option<SynodMessage<V>> {
        if b > self.ballot {
            // update current ballot
            self.ballot = b;
            // create promise message
            let promise = SynodMessage::MPromise(b, self.accepted.clone());
            Some(promise)
        } else {
            None
        }
    }

    fn handle_accept(&mut self, b: Ballot, value: V) -> Option<SynodMessage<V>> {
        if b >= self.ballot {
            // update current ballot
            self.ballot = b;
            // update the accepted value
            self.accepted = (b, value);
            // create accepted message
            let accepted = SynodMessage::MAccepted(b);
            Some(accepted)
        } else {
            None
        }
    }

    // pub fn accept(&mut self, b: u64, previous: (u64, V)) -> Option<u64> {
    //     if remote_ballot >= self.ballot {
    //         // update current ballot
    //         self.ballot = remote_ballot;
    //         // update accepted ballot and value
    //         self.accepted = Some((remote_ballot, value));
    //         // return accepted ballot
    //         Some(remote_ballot)
    //     } else {
    //         None
    //     }
    // }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn synod_flow() {
        let mut synod = Synod::new();

        synod.prepare(10);
        synod.accept(10, String::from("A"));
    }
}
